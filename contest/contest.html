<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Contest: Pacman Capture the Flag</title>
<style type="text/css">
<!--
.style1      { font-style: italic; font-weight: bold }
-->
</style>
<link href="projects.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.style2      { color: #990000 }
-->
</style>
</head>

<body>

<h2>Contest: Pacman Capture the Flag</h2>
<!--><em>Tournament on Wednesday, 12/5 @ 6pm</em><br>
<font color="#FF0000">Final version posted on 11/20</font><br>
<font color="#FF0000">Qualifying instructions and final contest layout posted on 11/27</font><br>-->
<blockquote>
<center>
<img src="capture_the_flag.png" width="540" height="210">
</center>
  <p><cite><center>Enough of defense,<br>
  Onto enemy terrain.<br>
  Capture all their food!</center></cite></p>
</blockquote>

<p><font color="#FF0000">[5/5] Final tournament rules, brackets and maps announced</font>

<p><font color="#FF0000">[4/13] New information about <a href="http://www.cs.utah.edu/~hal/courses/2009S_AI/contest/sub.html">submitting</a> to the <a href="http://www.cs.utah.edu/~hal/courses/2009S_AI/contest/results.html">nightly tournament</a> has been added to the contest details section at the bottom.  The nightly tournament is how you qualify for the finals.</font><br>

<h3>Final Tournament</h3>

<p>The final tournament will be held live in Soda 273 at 5pm on Wednesday May 6th.  Bring your agents with you!
  
<p>Each match-up will be decided in three games.  The first game will be played on <code>defaultCapture.lay</code>.  The other two games will be played on one of the 20 randomly generated maps now included in this distribution as <code>layouts/contest*Capture.lay</code>.  One of these mazes can be chosen at random using <code><a href="docs/mazeGenerator.html">mazeGenerator.py</a></code>.
  
<p>To watch games from the last <a href="http://www.cs.utah.edu/~hal/courses/2009S_AI/contest/results.html">nightly tournament</a>, download the server logs and use the <code><a href="docs/unpack.html">unpack.py</a></code> tool.  <code>python unpack.py [server-log] [team-name]</code> will generate replay files, which can be replayed with <code>python capture.py --replay [replay-file]</code>.  <font color="#FF0000">The server log for May 5 is corrupted, unfortunately.</font>
  
<p>The winner's bracket:
  
  <img src="bracket.png" />

<h3>Introduction</h3>
<p>The course contest involves a multi-player capture-the-flag variant of Pacman, where agents control both Pacman and ghosts in coordinated team-based strategies.  Your team will try to eat the food on the far side of the map, while defending the food on your home side.  The contest code is available as a <a href="contest.zip">zip archive</a>.
	
<table border="0" cellpadding="10">
  <tr><td><b>Key files to read:</b></td></tr>
  
  <tr><td><code><a href="docs/capture.html">capture.py</a></code> </td>
  <td>The main file that runs games locally.  This file also describes the new capture the flag GameState type and rules.</td></tr>

  <tr><td><code><a href="docs/pacclient.html">pacclient.py</a></code> </td>
  <td>The main file that runs games over the network. </td></tr>

  <tr><td><code><a href="docs/captureAgents.html">captureAgents.py</a></code> </td>
  <td>Some example agents for this variant of Pacman. </td></tr>

  <tr><td><b>Supporting files:</b></td></tr>

  <tr><td><code><a href="docs/game.html">game.py</a></code></td>
  <td>The logic behind how the Pacman world works.  This file describes several supporting types like AgentState, Agent, Direction, and Grid.</td></tr>

  <tr><td><code><a href="docs/util.html">util.py</a></code></td>
  <td>Useful data structures for implementing search algorithms.</td></tr>  

  <tr><td><code><a href="docs/distanceCalculator.html">distanceCalculator.py</a></code> </td>
  <td>Computes shortest paths between all maze positions. </td></tr>

  <tr><td><code><a href="docs/graphicsDisplay.html">graphicsDisplay.py</a></code></td>
  <td>Graphics for Pacman</td></tr>
    
    <tr><td><code><a href="docs/graphicsUtils.html">graphicsUtils.py</a></code></td>
  <td>Support for Pacman graphics</td></tr>

  <tr><td><code><a href="docs/textDisplay.html">textDisplay.py</a></code></td>
  <td>ASCII graphics for Pacman</td></tr>  

    <tr><td><code><a href="docs/keyboardAgents.html">keyboardAgents.py</a></code></td>
  <td>Keyboard interfaces to control Pacman</td></tr>

<!--  <tr><td><code><a href="docs/pygameDisplay.html">pygameDisplay.py</a></code></td>
  <td>New faster graphics for Pacman (in development)</td></tr>

  <tr><td><code><a href="docs/pygameAgents.html">pygameAgents.py</a></code></td>
  <td>Keyboard agents for the pygame graphics package</td></tr>  
  -->

    <tr><td><code><a href="docs/layout.html">layout.py</a></code></td>
  <td>Code for reading layout files and storing their contents</td></tr>

</table>

<p><strong>Academic Dishonesty:</strong> While we won't grade contests, we still expect you not to falsely represent your work.  <em>Please</em> don't let us down. 

<h3>Rules of Pacman Capture the Flag</h3>

<b>Layout:</b> The Pacman map is now divided into two halves: blue (right) and red (left).  Red agents (which all have even indices) must defend the red food while trying to eat the blue food.  When on the red side, a red agent is a ghost.  When crossing into enemy territory, the agent becomes a Pacman.  

<p><b>Scoring:</b>  When a Pacman eats a food dot, the food is permanently removed and one point is scored for that Pacman's team.  Red team scores are positive, while Blue team scores are negative.

<p><b>Eating Pacman:</b> When a Pacman is eaten by an opposing ghost, the Pacman returns to its starting position (as a ghost).  No points are awarded for eating an opponent. Ghosts can never be eaten. 
    	
<p><b>Winning:</b> A game ends when either one team eats all but two of the opponents' dots.  Games are also limited to 3000 agent moves.  If this move limit is reached, whichever team has eaten the most food wins. 

<p><b>Computation Time:</b> In online play, each agent will have only 0.5 seconds to choose an action.  If an action is not returned in this amount of time, the server will move the agent randomly.

<p><b>Observations:</b> Agents can only observe an opponent's configuration (position and direction) if they or their teammate is within 5 squares (Manhattan distance).  In addition, an agent always gets a noisy distance reading for each agent on the board, which can be used to approximately locate unobserved opponents.

<h3>Getting Started</h3>

By default, you can run a four-player game where the keyboard controls the red ghost and all other agents play offense:

<pre>python capture.py</pre>

The arrow keys control your character, which will change from ghost to Pacman when crossing the center line. 

<p>A wealth of options are available to you:

<pre>python capture.py --help</pre>

For example, use the following command to make the Blue team play a mix of offense and defense.

<pre>python capture.py -b OffenseDefenseAgents </pre>

There are six slots for agents, where agents 0, 2 and 4 are always on the red team and 1, 3 and 5 on the blue team.  Agents are created by agent factories (one for Red, one for Blue).  See the section on designing agents for a description of the agents invoked above. When judging the contest this semester, we will use only four agents (two from each side). 

When you're playing the local version (using capture.py), by default you can see where all the agents are.  The agents, however, typically do not know where opponents are (unless they are close by, according to the rules above).  When you play the online version (described below) you will not be able to see your opponents' agents.

<h3>Online Games</h3>

In order to facilitate testing of your agents against others' in the class, we have set up game servers that moderate games played over the network.  We will use this network setup to administer the final tournament.  Your agent factory is specified with <code>-a</code>.

<pre>python pacclient.py -a OffenseDefenseAgents</pre>

Look at the options with <code>-h</code>.  If you want to identify yourself to the server for stats tracking, you should supply a name and password.  If the name you supply is new, an account will be created for you.  If it is a name that is already used, you must supply the correct password or the server will not accept your connection.

<pre>python pacclient.py -U blitz -P noprisoners -a AllOffenseAgents</pre>

<p>Any agent that works in a local game should work equivalently in an online game.  However, there is a real-time element to the game: you have only 0.5 seconds (plus a little leeway for network lag) to choose a move.  The server will enforce this time limit, and will choose a move for you if you don't supply one in time. 
	
<h3>Designing Agents</h3>

Unlike project 2, an agent now has the more complex job of trading off offense versus defense and effectively functioning as a ghost and a Pacman in a team setting.   Furthermore, the limited information provided to your agent will likely necessitate some probabilistic tracking (like project 4).  Finally, the added time limit of computation introduces new challenges.

<p><b>Interface:</b> The <code>GameState</code> in <code><a href="docs/capture.html">capture.py</a></code> should look familiar, but contains new methods like <code>getRedFood</code>, which gets a grid of food on the red side (note that the grid is the size of the board, but is only true for cells on the red side with food).  Also, note that you can list a team's indices with <code>getRedTeamIndices</code>, or test membership with <code>isOnRedTeam</code>.  
	
<p>Finally, you can access the list of noisy distance observations via <code>getAgentDistances</code>.  These distances are within 6 of the truth, and the noise is chosen uniformly at random from the range [-6, 6] (e.g., if the true distance is 6, then each of {0, 1, ..., 12} is chosen with probability 1/13).  You can get the likelihood of a noisy reading using <code>getDistanceProb</code>.
	
<p>To get started designing your own agent, we recommend subclassing the <code>CaptureAgent</code> class.  This provides access to several convenience methods.  Some useful methods are:
	
<pre>
  def getFood(self, gameState):
    """
    Returns the food you're meant to eat. This is in the form
    of a matrix where m[x][y]=true if there is food you can
    eat (based on your team) in that square.
    """

  def getFoodYouAreDefending(self, gameState):
    """
    Returns the food you're meant to protect (i.e., that your
    opponent is supposed to eat). This is in the form of a
    matrix where m[x][y]=true if there is food at (x,y) that
    your opponent can eat.
    """
    
  def getOpponents(self, gameState):
    """
    Returns agent indices of your opponents. This is the list
    of the numbers of the agents (e.g., red might be "1,3,5")
    """
    
  def getTeam(self, gameState):
    """
    Returns agent indices of your team. This is the list of
    the numbers of the agents (e.g., red might be "1,3,5")
    """
    
  def getScore(self, gameState):
    """
    Returns how much you are beating the other team by in the
    form of a number that is the difference between your score
    and the opponents score. This number is negative if you're
    losing.
    """
    
  def getMazeDistance(self, pos1, pos2):
    """
    Returns the distance between two points; this is either
    the Manhattan distance early in the game, or actual
    shortest path maze distances once the computation is
    complete.
    
    The distancer computes the shortest path between pairs of
    points in the background, and starts using them as soon as
    they are ready. These are not just pre-computed ahead of
    time because of the time limit - we don't want to lose our
    turn because we're computing distances we don't need yet!
    """

  def getPreviousObservation(self):
    """
    Returns the GameState object corresponding to the last
    state this agent saw (the observed state of the game last
    time this agent moved - this may not include all of your
    opponent's agent locations exactly).
    """

  def getCurrentObservation(self):
    """
    Returns the GameState object corresponding this agent's
    current observation (the observed state of the game - this
    may not include all of your opponent's agent locations
    exactly).
    """
  
</pre>

<p><b>Baseline Agents:</b> To kickstart your agent design, we have provided you with two baseline agents.  They are both quite bad.  
The <code>OffensiveReflexAgent</code> moves toward the closest food on the opposing side.  The <code>DefensiveReflexAgent</code> wanders around on its own side and tries to chase down invaders it happens to see.

<p>To facilitate agent development, we provide code in <code><a href="docs/distanceCalculator.html">distanceCalculator.py</a></code> to supply shortest path maze distances as soon as they can be computed, but to supply Manhattan distances until then.  This approach demonstrates some of the techniques you might want to use when designing agents under time constraints (e.g., sharing information and computing in parallel). However, this is neither the only nor the best way to solve the maze distance problem.  

<p><b>Restrictions:</b> You are free to design any agent you want, and you need not use any of the code we have provided.  Because the tournament will be run using the online architecture, you can run your agent from your machine using any resources or code you want; you can even write code in different programming languages if you so desire.  Change pacclient.py at your own risk, though, because you don't want to break the network functionality.  

<p><b>Loading agents:</b>  Agents are chosen by agent factories, also specified in <code><a href="docs/captureAgents.html">captureAgents.py</a></code>.  You may also pass options to your agent factories (see <code>--help</code>), which can then be passed on to your agents.

<h3>Contest Details</h3>

The contest has three parts: a qualifying round, an exhibition match between UC Berkeley and U of Utah, and a final tournament.  
<ul>
    <li> <strong>Qualifying:</strong> Every night, we will post the <a href="http://www.cs.utah.edu/~hal/courses/2009S_AI/contest/results.html">results of a double-elimination tournament</a> among all submitted agents, including two sets of "qualifying agents".  To qualify for the final tournament, you must first submit your agent using these <a href="http://www.cs.utah.edu/~hal/courses/2009S_AI/contest/sub.html">instructions</a>.  Then, you must be ranked ahead of at least one of the qualifying agents in one of these nightly tournaments before the qualification deadline.  The earlier you submit your agents, the more chances you have to qualify!
    <li> <strong>Exhibition:</strong>  The current best agents by nightly ranking from Berkeley and Utah will compete for the glory and honor of their respective universities.  
    <li> <strong>Tournament:</strong> A final double-elimination tournament will be conducted live in the basement of Soda hall on the evening before the last day of class (Wednesday 5/6). The final lecture the next day will include replays of important matches. The final tournament will be similar to the <code>defaultCapture</code> layout.
</ul> 

<p><b>Important dates (subject to change):</b>
    
<table border="0" cellspacing="5" cellpadding="5">
    <tr><td>Tuesday </td><td>3/10</td><td>Contest announced and posted</td></tr>
    <tr><td>Tuesday </td><td>4/14</td><td>Qualification opens</td></tr>
    <tr><td>Tuesday </td><td>4/28</td><td>Exhibition match: Berkeley vs. Utah</td></tr>
    <tr><td>Thursday </td><td>4/30</td><td>Tournament layout revealed</td></tr>
    <tr><td>Sunday </td><td>5/3</td><td>Qualification closes</td></tr>
    <tr><td>Wednesday </td><td>5/6</td><td>Berkeley tournament</td></tr>
    <tr><td>Thursday </td><td>5/7</td><td>Awards ceremony in class</td></tr>
</table>    

<p><b>Teams:</b> You may work in teams of up to 5 people. 

<p><b>Prizes:</b> The top three teams will receive awards in class on Thursday 5/7, including shiny medals and extra credit points.   

<ul>
	<li> First Place: 1% overall point increase
	<li> Second Place: 0.75% overall point increase
	<li> Third Place: 0.5% overall point increase
</ul> 

<p><b>Bonus prizes:</b> If at least 30% of the class qualifies for the tournament, then <b>all prizes will be doubled</b>. Additionally, all qualifiers will get a 1% bonus on their final exam. Note that 2% overall (the top prize) is a lot: it is equivalent to 6.7% on the final.

<h3>Named Games</h3>

By default, when you connect to the server for a network game, you will be paired with the first unmatched opponent that connects. If you would like to play with a buddy, you can organize a game with a specific name on the server:

<pre>python pacclient.py -a KeyboardAgents -g MyCoolGame</pre>

Which will pair you only with the next player who requests "MyCoolGame"

<!--><p> This being an inherently social feature, the <a href="http://csua.berkeley.edu">CSUA</a> has set up an IRC channel for chatting about the project. It can be reached at:
<pre>Server: irc.csua.berkeley.edu
Channel: #cs188</pre>
Or can be accessed by web interface <a href="http://photonzero.com/cs188chat/">here</a>-->

<!-->
<h3>PyGame Graphics</h3>

We have included an improved graphics package with this release, based on the Python library <a href="http://www.pygame.org">Pygame</a>.  To use this extension, you must first install PyGame on your computer.  Follow these <a href="http://www.pygame.org/install.html">installation instructions</a>. It may take a bit of finagling to get it to run on a Mac; if you have troubles and would like to use Pygame, please talk to us during office hours.

<p> Once you have installed PyGame, you can run either the networked or local game using the improved (speedier) graphics.  

<pre>python capture.py -1 RandomAgent -G</pre>

The <code>KeyboardAgent</code> will not work with the PyGame graphics because it is tied to the Tk libraries used for the old graphics.  
<-->

<h3>Acknowledgements</h3>

We owe special thanks to Barak Michener and Ed Karuna for providing online networking infrastructure, improved graphics and debugging help.  

<p>

<img src="capture_the_flag2.png" width="785" height="444" />

<p> Have fun!  Please bring our attention to any problems you discover.
</body>

</html>
